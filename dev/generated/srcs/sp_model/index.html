<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model · Stochastic Flexibility Optimization</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Stochastic Flexibility Optimization</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Flexibility analysis using Stochastic Programing</a></li><li><span class="tocitem">Manuscripts</span><ul><li><a class="tocitem" href="../../flexibility_by_stochastic_programing/">Main Story</a></li></ul></li><li><span class="tocitem">Sources</span><ul><li class="is-active"><a class="tocitem" href>Model</a></li><li><a class="tocitem" href="../evaluation_utils/">Evaluation</a></li><li><a class="tocitem" href="../plot_utils/">Plotting</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Sources</a></li><li class="is-active"><a href>Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PIK-ICoNe/StochasticFlexibility/blob/master/docs/src/generated/srcs/sp_model.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">using StochasticPrograms
using Random

#
&quot;&quot;&quot;
Default values of system parameters.
- c_i - price of buying energy from the grid, Euro/kW
- c_o - price of selling energy to the grid, Euro/kW
- c_sto_op - price of operating storage. Could be replaced with storage losses. TODO
- asset_lifetime - expected lifetime of a component in years. Needed to bring investment and operational costs to the same timescale
- c_pv, c_wind - price of installing pv and wind components per kW peak, Euro/kWp
- c_storage - price of storage, Euro/kW
- c_heat_storage - TODO: heat layer units
- c_heatpump
- inv_budget - maximum investment budget, Euro
- recovery_time - time after the event, in which the system is allowed to deviate from background optimal schedule, h
- COP - heatpump efficiency coefficient
- heat_losses - losses in the heat storage
- penalty - price of non-delivery of flexibility, Euro
&quot;&quot;&quot;
default_es_pars = Dict((
    :c_i =&gt; .3,
    :c_o =&gt; .05,
    :c_sto_op =&gt; 0.0001,
    :asset_lifetime =&gt; 10.,
    :c_pv =&gt; 700.,
    :c_wind =&gt; 2000.,
    :c_storage =&gt; 600.,
    :c_heat_storage =&gt; 30.,
    :c_heatpump =&gt; 20.,
    :inv_budget =&gt; 500000000.,
    :recovery_time =&gt; 72,
    :COP =&gt; 0.8,
    :heat_losses =&gt; 0.01,
    :penalty =&gt; 10000.
))

&quot;&quot;&quot;
Draw a sample of n scenarios
&quot;&quot;&quot;
function simple_flex_sampler(n, F_max, t_max)
    [@scenario t_xi = rand(1:t_max) s_xi = rand([-1, 1]) F_xi = rand() * F_max probability = 1/n
        for i in 1:n]
end

&quot;&quot;&quot;
Get an array with a single pseudo scenario with no flexiblity.
This is useful for optimizing the system as if no flexibilty was introduced.
&quot;&quot;&quot;
function no_flex_pseudo_sampler()
    [@scenario t_xi = 1 s_xi = 1 F_xi = 0. probability = 1.
    ,]
end

&quot;&quot;&quot;
Define energy system.
Parameters:
- pv, wind - weather timeseries
- demand, heatdemand - demand timeseries
- p - dictionary with system parameters, such as component costs, losses and recovery time window
- strict_flex - bool, if false, finite penalty is used
&quot;&quot;&quot;
function define_energy_system(pv, wind, demand, heatdemand; p = default_es_pars, strict_flex=false)
    number_of_hours = minimum([length(pv), length(demand), length(wind)])
    c_sto_op = p[:c_sto_op]
    c_i = p[:c_i]
    c_o = p[:c_o]
    recovery_time = p[:recovery_time]
    COP = p[:COP]
    heat_losses = p[:heat_losses]
    energy_system = @stochastic_model begin
        @stage 1 begin
            @parameters begin</code></pre><p>Expected lifetime of components, years</p><pre><code class="language-julia hljs">                asset_lifetime = p[:asset_lifetime]</code></pre><p>Costs in Euro/1kWp</p><pre><code class="language-julia hljs">                c_pv = p[:c_pv]
                c_wind = p[:c_wind]
                c_storage = p[:c_storage]
                c_sto_op = c_sto_op
                c_i = c_i
                c_o = c_o
                c_heat_storage = p[:c_heat_storage]
                c_heatpump = p[:c_heatpump]
                COP = COP
                heat_losses = heat_losses</code></pre><p>Euro</p><pre><code class="language-julia hljs">                inv_budget = p[:inv_budget] # Make the problem bounded
            end
            lifetime_factor = asset_lifetime * 365 * 24 / number_of_hours</code></pre><p>Component units to be invested in, kWp</p><pre><code class="language-julia hljs">            @decision(model, u_pv &gt;= 0)
            @decision(model, u_wind &gt;= 0)
            @decision(model, u_storage &gt;= 0)
            @constraint(model, c_pv * u_pv + c_wind * u_wind + c_storage * u_storage &lt;= inv_budget)</code></pre><p>Grid connection</p><pre><code class="language-julia hljs">            @decision(model, gci[t in 1:number_of_hours] &gt;= 0)
            @decision(model, gco[t in 1:number_of_hours] &gt;= 0)</code></pre><p>Storage model</p><pre><code class="language-julia hljs">            @decision(model, sto_in[t in 1:number_of_hours] &gt;= 0) # into the bus from storage
            @decision(model, sto_out[t in 1:number_of_hours] &gt;= 0)
            @decision(model, sto_soc[t in 1:number_of_hours] &gt;= 0)
            @constraint(model, [t in 1:number_of_hours-1], sto_soc[t+1] == sto_soc[t] - sto_out[t] + sto_in[t])
            @constraint(model, [t in 1:number_of_hours], sto_soc[t] &lt;= u_storage)
            @constraint(model, sto_soc[1] == u_storage / 2)
            @constraint(model, sto_soc[number_of_hours] - sto_out[number_of_hours] + sto_in[number_of_hours] == sto_soc[1])</code></pre><p>Heat model</p><pre><code class="language-julia hljs">            @decision(model, u_heatpump &gt;= 0)
            @decision(model, u_heat_storage &gt;= 0)
            @decision(model, heat_sto_in[t in 1:number_of_hours] &gt;= 0) # from the heat storage
            @decision(model, heat_sto_out[t in 1:number_of_hours] &gt;= 0)
            @decision(model, heat_sto_soc[t in 1:number_of_hours] &gt;= 0)
            @decision(model, heatpumpflow[t in 1:number_of_hours] &gt;= 0)

            @constraint(model, [t in 1:number_of_hours-1], heat_sto_soc[t+1] == heat_sto_soc[t] - heat_sto_out[t] + heat_sto_in[t])
            @constraint(model, [t in 1:number_of_hours], heat_sto_soc[t] &lt;= u_heat_storage)
            @constraint(model, heat_sto_soc[1] == u_heat_storage / 2)
            @constraint(model, heat_sto_soc[number_of_hours] - heat_sto_out[number_of_hours] + heat_sto_in[number_of_hours] == heat_sto_soc[1])
            @constraint(model, [t in 1:number_of_hours], heatpumpflow[t] &lt;= u_heatpump)</code></pre><p>Energy balance</p><pre><code class="language-julia hljs">            @constraint(model, [t in 1:number_of_hours],
            gci[t] - gco[t] + u_pv * pv[t] + u_wind * wind[t] - demand[t] + sto_in[t] - sto_out[t] - heatpumpflow[t] == 0)</code></pre><p>Heat balance</p><pre><code class="language-julia hljs">            @constraint(model, [t in 1:number_of_hours], -heatdemand[t] - heat_sto_in[t] + heat_sto_out[t] + COP*heatpumpflow[t] - heat_losses*heat_sto_soc[t] == 0)</code></pre><p>Investment costs ... ... and background operational schedule</p><pre><code class="language-julia hljs">            @objective(model, Min, (u_pv * c_pv + u_wind * c_wind + u_storage * c_storage
            + u_heat_storage * c_heat_storage + u_heatpump * c_heatpump) / lifetime_factor
            + c_i * sum(gci) - c_o * sum(gco) +
            c_sto_op * sum(sto_in) + c_sto_op * sum(sto_out))
        end
        @stage 2 begin
            @parameters begin
                recovery_time = recovery_time
                c_sto_op = c_sto_op
                c_i = c_i
                c_o = c_o
                penalty = p[:penalty]
                heat_losses = heat_losses
                COP = COP
            end
            @uncertain t_xi s_xi F_xi # t_xi the time of flexibility demand, s_xi - sign (±1 or 0)
            t_xi_final = t_xi + recovery_time - 1
            @known(model, u_pv)
            @known(model, u_wind)
            @known(model, u_storage)
            @known(model, gci)
            @known(model, gco)
            @known(model, sto_in)
            @known(model, sto_out)</code></pre><p>Post event components Grid connection</p><pre><code class="language-julia hljs">            @recourse(model, gci2[t in 1:recovery_time] &gt;= 0)
            @recourse(model, gco2[t in 1:recovery_time] &gt;= 0)</code></pre><p>Storage model</p><pre><code class="language-julia hljs">            @recourse(model, sto_in2[t in 1:recovery_time] &gt;= 0) # into the bus from storage
            @recourse(model, sto_out2[t in 1:recovery_time] &gt;= 0)
            @recourse(model, sto_soc2[t in 1:recovery_time] &gt;= 0)
            @constraint(model, [t in 1:recovery_time-1], sto_soc2[t+1] == sto_soc2[t] - sto_out2[t] + sto_in2[t])
            @constraint(model, [t in 1:recovery_time], sto_soc2[t] &lt;= u_storage)
            @constraint(model, sto_soc2[1] == sto_soc[t_xi])
            @constraint(model, sto_soc2[recovery_time] - sto_out2[recovery_time] + sto_in2[recovery_time] == sto_soc[t_xi+recovery_time])</code></pre><p>Heat model</p><pre><code class="language-julia hljs">            @recourse(model, heat_sto_in2[t in 1:recovery_time] &gt;= 0) # from the heat storage
            @recourse(model, heat_sto_out2[t in 1:recovery_time] &gt;= 0)
            @recourse(model, heat_sto_soc2[t in 1:recovery_time] &gt;= 0)
            @recourse(model, heatpumpflow2[t in 1:recovery_time] &gt;= 0)
            @constraint(model, [t in 1:recovery_time-1], heat_sto_soc2[t+1] == heat_sto_soc2[t] - heat_sto_out2[t] + heat_sto_in2[t])
            @constraint(model, [t in 1:recovery_time], heat_sto_soc2[t] &lt;= u_heat_storage)
            @constraint(model, heat_sto_soc2[1] == heat_sto_soc[t_xi])
            @constraint(model, heat_sto_soc2[recovery_time] - heat_sto_out2[recovery_time] + heat_sto_in2[recovery_time] == heat_sto_soc[t_xi+recovery_time])
            @constraint(model, [t in 1:recovery_time], heatpumpflow2[t] &lt;= u_heatpump)</code></pre><p>Event energy balance The storage and other fast acting components use the recourse variables here. They provide the balance. Grid connection is not allowed, as we are suporting the grid here.</p><pre><code class="language-julia hljs">            @constraint(model, gci2[1] - gco2[1] + u_pv * pv[t_xi] + u_wind * wind[t_xi]
             - demand[t_xi] + sto_in2[1] - sto_out2[1]
             - heatpumpflow2[1] - F_xi * s_xi == 0) # TODO CHeck that our sign convention on positive and negative flexibility agrees with literature
            if strict_flex
                @constraint(model, gci2[1] == gci[t_xi])
                @constraint(model, gco2[1] == gco[t_xi])
            end
            # Utility variables to linearize min|gci[t_xi]-gci2[1]|
            @recourse(model, gi1&gt;=0)
            @recourse(model, gi2&gt;=0)
            @constraint(model, gci2[1]-gci[t_xi] == gi1-gi2)
            @recourse(model, go1&gt;=0)
            @recourse(model, go2&gt;=0)
            @constraint(model, gco2[1]-gco[t_xi] == go1-go2)</code></pre><p>Post event energy balance</p><pre><code class="language-julia hljs">            @constraint(model, [t in 2:recovery_time],
            gci2[t] - gco2[t]
            + u_pv * pv[t + t_xi - 1] + u_wind * wind[t + t_xi - 1]
            - demand[t + t_xi - 1] + sto_in2[t] - sto_out2[t] - heatpumpflow2[t] == 0)</code></pre><p>Heat balance</p><pre><code class="language-julia hljs">            @constraint(model, [t in 1:recovery_time], -heatdemand[t] - heat_sto_in2[t] + heat_sto_out2[t] + COP*heatpumpflow2[t] - heat_losses*heat_sto_soc2[t] == 0)</code></pre><p>The objective function is the difference between the adjusted schedule and the final schedule plus the penalty. TODO: We only evaluate the cost of individual events, so we should multiply the expectation value with the expected number of events, e.g. one per week. I tried to implement this by scaling the objective function here, but that made the problem unbounded.</p><pre><code class="language-julia hljs">            @objective(model, Min,
            + c_i * (sum(gci2) - sum(gci[t_xi:t_xi_final]))
            - c_o * (sum(gco2) - sum(gco[t_xi:t_xi_final]))
            + penalty * (gi1 + gi2) + penalty * (go1 + go2)
            + c_sto_op * (sum(sto_in2) + sum(sto_out2)
            - sum(sto_in[t_xi:t_xi_final]) - sum(sto_out[t_xi:t_xi_final])))
        end
    end
    energy_system
end

&quot;&quot;&quot;
Get decision variables associated with investment rather than system operation.
&quot;&quot;&quot;
get_investments(sp) = Dict((
    :u_pv =&gt; value.(sp[1, :u_pv]),
    :u_wind =&gt; value.(sp[1, :u_wind]),
    :u_storage =&gt; value.(sp[1, :u_storage]),
    :u_heatpump =&gt; value.(sp[1, :u_heatpump]),
    :u_heat_storage =&gt; value.(sp[1, :u_heat_storage])
))

&quot;&quot;&quot;
Fix the investment variables.
&quot;&quot;&quot;
function fix_investment!(sp, investments)
    for (var_sym, value) in zip(keys(investments), values(investments))
        fix(decision_by_name(sp, 1, string(var_sym)), value)
    end
end

function unfix_investment!(sp, investments)
    for var_sym in keys(investments)
        unfix(decision_by_name(sp, 1, string(var_sym)))
    end
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../flexibility_by_stochastic_programing/">« Main Story</a><a class="docs-footer-nextpage" href="../evaluation_utils/">Evaluation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Thursday 2 June 2022 11:40">Thursday 2 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
